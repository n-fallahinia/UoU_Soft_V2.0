// generated by Fast Light User Interface Designer (fluid) version 1.0110

#include "main.h"
#include "CameraControl.h"
#include "Images.h"
#include <stdio.h>
#include "ImageDisplay.h"
static char demo_dir[] = "~/haptics/bin/"; 
static CameraControl camera_m; 
static Images image_buff; 
static Training current_training; 
static bool flag_camera_on = 0; 
static bool flag_force_ready = 0; 
static bool flag_start_training = 0; 
static bool flag_camera_capture = 0;
static bool flag_thumb = false; 
static bool flag_image_ready; 
#define GAIN_TEXT 10
static int image_counter = 0; 
static char data_dir[] = "../data/";
static char image_dir[] = "../images/"; 

Fl_Double_Window *control_window=(Fl_Double_Window *)0;

Plot2DView *box_maglev_rotation=(Plot2DView *)0;

Graph3DAxis *box_maglev_position=(Graph3DAxis *)0;

CubeView *display_force=(CubeView *)0;

Fl_Group *maglev_position=(Fl_Group *)0;

Fl_Group *position_gain_sliders=(Fl_Group *)0;

Fl_Group *position_gain_sliders_x=(Fl_Group *)0;

Fl_Value_Slider *position_gain_x_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_x_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_x_D=(Fl_Value_Slider *)0;

Fl_Group *position_gain_sliders_y=(Fl_Group *)0;

Fl_Value_Slider *position_gain_y_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_y_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_y_D=(Fl_Value_Slider *)0;

Fl_Group *position_gain_sliders_z=(Fl_Group *)0;

Fl_Value_Slider *position_gain_z_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_z_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *position_gain_z_D=(Fl_Value_Slider *)0;

Fl_Group *rotation_gain_sliders_x=(Fl_Group *)0;

Fl_Value_Slider *rotation_gain_x_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_x_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_x_D=(Fl_Value_Slider *)0;

Fl_Group *rotation_gain_sliders_y=(Fl_Group *)0;

Fl_Value_Slider *rotation_gain_y_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_y_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_y_D=(Fl_Value_Slider *)0;

Fl_Group *rotation_gain_sliders_z=(Fl_Group *)0;

Fl_Value_Slider *rotation_gain_z_P=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_z_I=(Fl_Value_Slider *)0;

Fl_Value_Slider *rotation_gain_z_D=(Fl_Value_Slider *)0;

Fl_Button *button_maglev_connect_separate=(Fl_Button *)0;

static void cb_button_maglev_connect_separate(Fl_Button*, void*) {
  // Check the current state of the Maglev
    if (maglev_m.flag_maglev_start)
    {
        // Synchronize the buttons
        button_maglev_connect_separate->clear();
        button_maglev_connect->clear();
        
        // Land the Maglev, if needed
        if ( button_maglev_lift_land -> value() )
        {
                button_maglev_lift_land_separate->clear();
                button_maglev_lift_land->clear();
                maglev_m.maglevLand (  );
        }
        
        // Turn off the Maglev
        maglev_m.maglevTurnOff ( );
        
        // Activate the thumb checkboxes
        check_calibrate_thumb->activate();
        check_calibrate_thumb_separate->activate();
    }
    else
    {
        // Synchronize the buttons
        button_maglev_connect_separate->set();
        button_maglev_connect->set();
        
        // Start the force sensor
        force_sensor_m.startForceSensor();
        
        // Turn on the "draw force reading" callback
        printf("Turning on a callback to draw the force sensor readings (%5.3f)\n", 1.0/FORCE_FREQUENCY);
        Fl::add_timeout(1.0/FORCE_FREQUENCY, forceSensorReading);
        display_force->flag_force_display = true;
        
        // Connect to the Maglev
        maglev_m.maglevConnect (  );
        
        // Deactivate the Thumb Calibration checkbox
        check_calibrate_thumb->deactivate();
        check_calibrate_thumb_separate->deactivate();
        
        // Turn on the "draw maglev position" callback
        printf("Turning on a callback to draw the Maglev position readings (%5.3f)\n", 1.0/MAGLEV_FREQUENCY);
        Fl::add_timeout(1.0/MAGLEV_FREQUENCY, maglevPositionReading);
        
        // Turn on the Maglev Position Display
        box_maglev_position->flag_maglev_position = true;
        box_maglev_rotation->flag_rotation_display = true;
    };
    }

Fl_Button *button_maglev_lift_land_separate=(Fl_Button *)0;

static void cb_button_maglev_lift_land_separate(Fl_Button*, void*) {
  // Make sure the "real" button matches this one
    if (button_maglev_lift_land_separate->value())
    {
        button_maglev_lift_land->set();
    }
    else
    {
        button_maglev_lift_land->clear();
    }

    if ( button_maglev_lift_land->value() )
    {
        // Have the Maglev take off
        maglev_m.maglevTakeOff ( flag_thumb );
        
        // Load the Maglev internal gains into the slider bars
        maglev_m.maglevGetInternalGains();
        position_gain_x_P->value(maglev_m.current_internal_gains[0][0]);
        position_gain_x_I->value(maglev_m.current_internal_gains[0][1]);
        position_gain_x_D->value(maglev_m.current_internal_gains[0][2]);
        
        position_gain_y_P->value(maglev_m.current_internal_gains[1][0]);
        position_gain_y_I->value(maglev_m.current_internal_gains[1][1]);
        position_gain_y_D->value(maglev_m.current_internal_gains[1][2]);
        
        position_gain_z_P->value(maglev_m.current_internal_gains[2][0]);
        position_gain_z_I->value(maglev_m.current_internal_gains[2][1]);
        position_gain_z_D->value(maglev_m.current_internal_gains[2][2]);
        
        rotation_gain_x_P->value(maglev_m.current_internal_gains[3][0]);
        rotation_gain_x_I->value(maglev_m.current_internal_gains[3][1]);
        rotation_gain_x_D->value(maglev_m.current_internal_gains[3][2]);
        
        rotation_gain_y_P->value(maglev_m.current_internal_gains[4][0]);
        rotation_gain_y_I->value(maglev_m.current_internal_gains[4][1]);
        rotation_gain_y_D->value(maglev_m.current_internal_gains[4][2]);
        
        rotation_gain_z_P->value(maglev_m.current_internal_gains[5][0]);
        rotation_gain_z_I->value(maglev_m.current_internal_gains[5][1]);
        rotation_gain_z_D->value(maglev_m.current_internal_gains[5][2]);
        
        // Load the Maglev operating frequency into the slider bar
        slider_maglev_frequency->value(maglev_m.maglevGetFrequency( ));
    }
    else
    {
        // Land the Maglev
        maglev_m.maglevLand (  );
    };
}

Fl_Value_Slider *slider_maglev_frequency=(Fl_Value_Slider *)0;

static void cb_slider_maglev_frequency(Fl_Value_Slider*, void*) {
  
  maglev_m.maglevSetFrequency( slider_maglev_frequency->value() );
}

Fl_Check_Button *check_calibrate_thumb_separate=(Fl_Check_Button *)0;

static void cb_check_calibrate_thumb_separate(Fl_Check_Button*, void*) {
  // Make sure the "real" checkbox matches this one
    if (check_calibrate_thumb_separate->value())
    {
        check_calibrate_thumb->set();
        flag_thumb = true;
        desired_force_x->value(1.0);
        desired_force_x->maximum(0.0);
        desired_force_x->minimum(10.0);
        desired_force_z->value(0.0);
        desired_force_z->maximum(-5.0);
        desired_force_z->minimum(5.0);
        maglev_m.desired_force[0] = 1.0;
        maglev_m.desired_force[2] = 0.0;
    }
    else
    {
        check_calibrate_thumb->clear();
        flag_thumb = false;
        desired_force_x->value(0.0);
        desired_force_x->maximum(-5.0);
        desired_force_x->minimum(5.0);
        desired_force_z->value(-1.0);
        desired_force_z->maximum(-10.0);
        desired_force_z->minimum(0.0);
        maglev_m.desired_force[0] = 0.0;
        maglev_m.desired_force[2] = -1.0;
    };
}

Fl_Group *demo_buttons=(Fl_Group *)0;

static void cb_Sine(Fl_Button*, void*) {
  char file[100];
    sprintf( file, "%ssine_texture_linux &", demo_dir );
    system( file );
}

static void cb_Sine1(Fl_Button*, void*) {
  char file[100];
    sprintf( file, "%ssine_motion_linux &", demo_dir );
    system( file );
}

static void cb_Dither(Fl_Button*, void*) {
  char file[100];
    sprintf( file, "%sdither_texture_linux &", demo_dir );
    system( file );
}

static void cb_Bunny(Fl_Button*, void*) {
  char file[100];
    sprintf( file, "%sbunny_linux &", demo_dir );
    system( file );
}

static void cb_Cube(Fl_Button*, void*) {
  char file[100];
    sprintf( file, "%scube_linux &", demo_dir );
    system( file );
}

Fl_Group *force_controller=(Fl_Group *)0;

Fl_Group *force_gain_sliders=(Fl_Group *)0;

Fl_Group *force_gain_sliders_x=(Fl_Group *)0;

Fl_Value_Slider *force_gain_x_P=(Fl_Value_Slider *)0;

static void cb_force_gain_x_P(Fl_Value_Slider*, void*) {
  // x -> row 0 
    // P -> col 0
    maglev_m.current_force_gains[0][0] = force_gain_x_P->value();
    //printf("%5.2f | %5.2f\n", force_gain_x_P->value(), display_force->height_x);
    force_control_parameter_update;
}

Fl_Value_Slider *force_gain_x_I=(Fl_Value_Slider *)0;

static void cb_force_gain_x_I(Fl_Value_Slider*, void*) {
  // x -> row 0 
    // I -> col 1
    maglev_m.current_force_gains[0][1] = force_gain_x_I->value();
    ;
}

Fl_Value_Slider *force_gain_x_D=(Fl_Value_Slider *)0;

static void cb_force_gain_x_D(Fl_Value_Slider*, void*) {
  // x -> row 0 
    // D -> col 2
    maglev_m.current_force_gains[0][2] = force_gain_x_D->value();
    force_control_parameter_update;
}

Fl_Group *force_gain_sliders_y=(Fl_Group *)0;

Fl_Value_Slider *force_gain_y_P=(Fl_Value_Slider *)0;

static void cb_force_gain_y_P(Fl_Value_Slider*, void*) {
    // y -> row 1 
    // P -> col 0
    maglev_m.current_force_gains[1][0] = force_gain_y_P->value();
    //force_control_parameter_update;
}

Fl_Value_Slider *force_gain_y_I=(Fl_Value_Slider *)0;

static void cb_force_gain_y_I(Fl_Value_Slider*, void*) {
  // y -> row 1 
    // D -> col 0
    maglev_m.current_force_gains[1][1] = force_gain_y_I->value();
    //force_control_parameter_update;
}

Fl_Value_Slider *force_gain_y_D=(Fl_Value_Slider *)0;

static void cb_force_gain_y_D(Fl_Value_Slider*, void*) {
  // t -> row 1 
    // D -> col 2
    maglev_m.current_force_gains[1][2] = force_gain_y_D->value();
    //force_control_parameter_update;
}

Fl_Group *force_gain_sliders_z=(Fl_Group *)0;

Fl_Value_Slider *force_gain_z_P=(Fl_Value_Slider *)0;

static void cb_force_gain_z_P(Fl_Value_Slider*, void*) {
  // z -> row 2 
    // P -> col 0
    maglev_m.current_force_gains[2][0] = force_gain_z_P->value();
    //force_control_parameter_update;
}

Fl_Value_Slider *force_gain_z_I=(Fl_Value_Slider *)0;

static void cb_force_gain_z_I(Fl_Value_Slider*, void*) {
  // z -> row 2 
    // I -> col 1
    maglev_m.current_force_gains[2][1] = force_gain_z_I->value();
    //force_control_parameter_update;
}

Fl_Value_Slider *force_gain_z_D=(Fl_Value_Slider *)0;

static void cb_force_gain_z_D(Fl_Value_Slider*, void*) {
  // z -> row 2 
    // D -> col 2
    maglev_m.current_force_gains[2][2] = force_gain_z_D->value();
    //force_control_parameter_update;
}

Fl_Group *target_forces=(Fl_Group *)0;

Fl_Value_Slider *desired_force_x=(Fl_Value_Slider *)0;

static void cb_desired_force_x(Fl_Value_Slider*, void*) {
  // Set desired force
	maglev_m.desired_force[0] = desired_force_x->value();
}

Fl_Value_Slider *desired_force_y=(Fl_Value_Slider *)0;

static void cb_desired_force_y(Fl_Value_Slider*, void*) {
  // Set desired force
	maglev_m.desired_force[1] = desired_force_y->value();
}

Fl_Value_Slider *desired_force_z=(Fl_Value_Slider *)0;

static void cb_desired_force_z(Fl_Value_Slider*, void*) {
  // Set desired force
	maglev_m.desired_force[2] = desired_force_z->value();
}

Fl_Group *target_positions=(Fl_Group *)0;

Fl_Value_Slider *desired_position_x=(Fl_Value_Slider *)0;

static void cb_desired_position_x(Fl_Value_Slider*, void*) {
  // Set desired position
	maglev_m.desired_position[0] = desired_position_x->value() / 1000.0;
}

Fl_Value_Slider *desired_position_y=(Fl_Value_Slider *)0;

static void cb_desired_position_y(Fl_Value_Slider*, void*) {
  // Set desired position
	maglev_m.desired_position[1] = desired_position_y->value() / 1000.0;
}

Fl_Value_Slider *desired_position_z=(Fl_Value_Slider *)0;

static void cb_desired_position_z(Fl_Value_Slider*, void*) {
  // Set desired position
	maglev_m.desired_position[2] = desired_position_z->value() / 1000.0;
}

Fl_Value_Slider *desired_rotation_x=(Fl_Value_Slider *)0;

static void cb_desired_rotation_x(Fl_Value_Slider*, void*) {
  // Set desired position
	maglev_m.desired_position[3] = desired_rotation_x->value() * PI / 180.0;
}

Fl_Value_Slider *desired_rotation_y=(Fl_Value_Slider *)0;

static void cb_desired_rotation_y(Fl_Value_Slider*, void*) {
  // Set desired position
	maglev_m.desired_position[4] = desired_rotation_y->value() * PI / 180.0;
}

Fl_Value_Slider *desired_rotation_z=(Fl_Value_Slider *)0;

static void cb_desired_rotation_z(Fl_Value_Slider*, void*) {
  // Set desired position
	maglev_m.desired_position[5] = desired_rotation_z->value() * PI / 180.0;
}

Fl_Button *start_force_controller_separate=(Fl_Button *)0;

static void cb_start_force_controller_separate(Fl_Button*, void*) {
  // Determine whether the external controller is running
    if (maglev_m.flag_force_control_start)
    {
        // Synchronize both buttons -- Shutting off the external controller
        start_force_controller->clear();
        start_force_controller_separate->clear();
        
        // Stop the force controller
        maglev_m.maglevStopForceController();
        
        ///////////////////////////////////////////////////////////////////////////
        // Set the position control sliders to the values of the position gains
        ///////////////////////////////////////////////////////////////////////////
        
        // x-direction position gains
        position_gain_x_P->value(maglev_m.current_internal_gains[0][0]);
        position_gain_x_I->value(maglev_m.current_internal_gains[0][1]);
        position_gain_x_D->value(maglev_m.current_internal_gains[0][2]);
        
        // y-direction position gains
        position_gain_y_P->value(maglev_m.current_internal_gains[1][0]);
        position_gain_y_I->value(maglev_m.current_internal_gains[1][1]);
        position_gain_y_D->value(maglev_m.current_internal_gains[1][2]);
        
        // z-direction position gains
        position_gain_z_P->value(maglev_m.current_internal_gains[2][0]);
        position_gain_z_I->value(maglev_m.current_internal_gains[2][1]);
        position_gain_z_D->value(maglev_m.current_internal_gains[2][2]);
        
        // x-direction rotation gains
        rotation_gain_x_P->value(maglev_m.current_internal_gains[3][0]);
        rotation_gain_x_I->value(maglev_m.current_internal_gains[3][1]);
        rotation_gain_x_D->value(maglev_m.current_internal_gains[3][2]);
        
        // y-direction rotation gains
        rotation_gain_y_P->value(maglev_m.current_internal_gains[4][0]);
        rotation_gain_y_I->value(maglev_m.current_internal_gains[4][1]);
        rotation_gain_y_D->value(maglev_m.current_internal_gains[4][2]);
        
        // z-direction rotation gains
        rotation_gain_z_P->value(maglev_m.current_internal_gains[5][0]);
        rotation_gain_z_I->value(maglev_m.current_internal_gains[5][1]);
        rotation_gain_z_D->value(maglev_m.current_internal_gains[5][2]);
    }
    else if(maglev_m.flag_maglev_start && force_sensor_m.flag_force_sensor)
    {
        // Synchronize both buttons -- Turning on the external controller
        start_force_controller->set();
        start_force_controller_separate->set();
        
        // Start the force controller
	maglev_m.maglevStartForceController();
	
	///////////////////////////////////////////////////////////////////////////
	// Set the force control sliders to the values of the force gains
	///////////////////////////////////////////////////////////////////////////
	
	// x-direction force gains
	force_gain_x_P->value(maglev_m.current_force_gains[0][0]);
	force_gain_x_I->value(maglev_m.current_force_gains[0][1]);
	force_gain_x_D->value(maglev_m.current_force_gains[0][2]);
	
	// y-direction force gains
	force_gain_y_P->value(maglev_m.current_force_gains[1][0]);
	force_gain_y_I->value(maglev_m.current_force_gains[1][1]);
	force_gain_y_D->value(maglev_m.current_force_gains[1][2]);
	
	// z-direction force gains
	force_gain_z_P->value(maglev_m.current_force_gains[2][0]);
	force_gain_z_I->value(maglev_m.current_force_gains[2][1]);
	force_gain_z_D->value(maglev_m.current_force_gains[2][2]);
	
	///////////////////////////////////////////////////////////////////////////
	// Set the position control sliders to the values of the position gains
	///////////////////////////////////////////////////////////////////////////
	
	// x-direction position gains
	position_gain_x_P->value(maglev_m.current_position_gains[0][0]);
	position_gain_x_I->value(maglev_m.current_position_gains[0][1]);
	position_gain_x_D->value(maglev_m.current_position_gains[0][2]);
	
	// y-direction position gains
	position_gain_y_P->value(maglev_m.current_position_gains[1][0]);
	position_gain_y_I->value(maglev_m.current_position_gains[1][1]);
	position_gain_y_D->value(maglev_m.current_position_gains[1][2]);
	
	// z-direction position gains
	position_gain_z_P->value(maglev_m.current_position_gains[2][0]);
	position_gain_z_I->value(maglev_m.current_position_gains[2][1]);
	position_gain_z_D->value(maglev_m.current_position_gains[2][2]);
	
	// x-direction rotation gains
	rotation_gain_x_P->value(maglev_m.current_position_gains[3][0]);
	rotation_gain_x_I->value(maglev_m.current_position_gains[3][1]);
	rotation_gain_x_D->value(maglev_m.current_position_gains[3][2]);
	
	// y-direction rotation gains
	rotation_gain_y_P->value(maglev_m.current_position_gains[4][0]);
	rotation_gain_y_I->value(maglev_m.current_position_gains[4][1]);
	rotation_gain_y_D->value(maglev_m.current_position_gains[4][2]);
	
	// z-direction rotation gains
	rotation_gain_z_P->value(maglev_m.current_position_gains[5][0]);
	rotation_gain_z_I->value(maglev_m.current_position_gains[5][1]);
	rotation_gain_z_D->value(maglev_m.current_position_gains[5][2]);
    }
    else
    {
        // Synchronize both buttons -- The external controller will not be running
        start_force_controller->clear();
        start_force_controller_separate->clear();
        
        // Explain to the user why the external force controller is not going to start
        printf("Cannot start the external controller:\n");
        if (!maglev_m.flag_maglev_start)
        {
                printf("\tThe Maglev is not on!\n");
        }
        if (!force_sensor_m.flag_force_sensor)
        {
                printf("\tThe force sensor is not on!\n");
        }
    };
}

static void cb_Save(Fl_Button*, void*) {
  maglev_m.maglevSaveGains();
}

static void cb_Save1(Fl_Button*, void*) {
  maglev_m.maglevSaveForce();
}

static void cb_Stop(Fl_Button*, void*) {
  maglev_m.maglevStopSaveForce();
}

Fl_Group *system_id=(Fl_Group *)0;

Fl_Value_Slider *slide_force_magnitude=(Fl_Value_Slider *)0;

Fl_Value_Slider *slide_force_power=(Fl_Value_Slider *)0;

Fl_Text_Display *force_frequency=(Fl_Text_Display *)0;

// %%%%%%%%%%%%%%%%%%%%%%%% Camer Seperate %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Fl_Group *camera_control=(Fl_Group *)0;

Fl_Group *camera_settings=(Fl_Group *)0;

ImageDisplay *image_display_b=(ImageDisplay *)0;

Fl_Value_Slider *camera_brightness=(Fl_Value_Slider *)0;

Fl_Value_Slider *camera_exposure=(Fl_Value_Slider *)0;

Fl_Value_Slider *camera_gamma=(Fl_Value_Slider *)0;

Fl_Value_Slider *camera_shutter=(Fl_Value_Slider *)0;

Fl_Value_Slider *camera_framerate=(Fl_Value_Slider *)0;

Fl_Value_Slider *camera_gain=(Fl_Value_Slider *)0;

Fl_Button *camera_load_settings=(Fl_Button *)0;

Fl_Button *camera_save_settings=(Fl_Button *)0;

Fl_Button *button_start_camera_separate=(Fl_Button *)0;

static void cb_button_start_camera_separate(Fl_Button*, void*) {
  if (button_start_camera_separate->value())
    {
        // printf("HERE_1!!!!!!1");
        // Make sure the "real" button on the all_together tab is synchronized
        button_start_camera->set();
        
        // Start the camera
        camera_m.initCamera();
        camera_m.startCamera();
        
        // Determine the size of the camera images and allocate memory for an image
        int cols = camera_m.num_cols;
        int rows = camera_m.num_rows;
        int inc = camera_m.num_colors;
        unsigned char temp_image[cols*rows*inc];
        
        // Get a new image from the camera
        camera_m.grabImage();
        camera_m.getImage( temp_image );
        
        // Write the image to the image buffer
        image_buff.writeImage( rows, cols, inc, temp_image );
        
        //Set the timers for taking new images and displaying them
        Fl::add_timeout(1.0/CAMERA_FREQUENCY, takeImage, NULL);
        Fl::add_timeout(1.0/CAMERA_FREQUENCY, displayImage, NULL);
        
        // Set the "camera on" flag
        flag_camera_on = 1;
    }
    else
    {
      // printf("HERE_2!!!!!!");
      // Make sure the "real" button on the all_together tab is synchronized
      button_start_camera->clear();

      // Turn the camera off
      Fl::remove_timeout(takeImage, NULL);
      Fl::remove_timeout(displayImage, NULL);
      flag_camera_on = 0;

      // Wait for the last callback to run
      Fl::wait(3);

      // Remove the camera handles
      camera_m.turnOffCamera();
    };
}

static void cb_(Fl_Button*, void*) {
  //if ( flag_camera_start )
  //	fl_draw_image ( current_image, display_x, display_y, display_w, display_h, 3, 0);
}

Fl_Button *button_record=(Fl_Button *)0;

static void cb_button_record(Fl_Button*, void*) {
  // CAMERA_TEST_CODE;
    if(access(image_dir,F_OK))
    {
	    printf("===========================\nThe data directory does not exist...creating it!\n===========================\n");
	    int error = mkdir(image_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
	    if(error == -1 )
	    {
		    printf("Got an error!\n");
	    }
    }

    if (flag_camera_on == 0)
    {
      printf("Please turn the camera on!\n");
    }
    //Set flag

    flag_camera_capture = 1;
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%% Training Seperate %%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Fl_Group *training_trajectories=(Fl_Group *)0;

static void cb_Select(Fl_Button*, void*) {
  /*training_browser->load(".", 1);


    training_file_name->value( training_browser->text(training_browser->value()) );
    */
    Fl_File_Chooser* fc = new Fl_File_Chooser("./trajGen","Text Files (*.{txt,dat,tex})",Fl_File_Chooser::SINGLE,"Text File");
    fc->callback(fileChooserCallback);
    fc->show();
}

Fl_Input *training_file_name_separate=(Fl_Input *)0;

Fl_Button *read_trajectory_file_separate=(Fl_Button *)0;

static void cb_read_trajectory_file_separate(Fl_Button*, void*) {
  //Load the training trajectory from the file

 //Check if the file name is valid

 char filename[100];
 sprintf(filename, "%s", training_file_name->value());
 //File open
 current_training.ReadTrajectoryFile(filename);
}

static void cb_Start(Fl_Button*, void*) {
  //Check other things are ready
    //Camera

    if(access(data_dir,F_OK))
    {
	printf("===========================\nThe data directory does not exist...creating it!\n===========================\n");
	int error = mkdir(data_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
	if(error > 0)
	{
		printf("Got an error!\n");
	}
    }

    if ( flag_camera_on == 0 || start_force_controller->value() == 0 
	|| current_training.flag_trajectory_ready == 0)
    {
	printf("Please turn on the controller and start the camera!\n");
	current_training.current_count = 0;
    //	return;
    }

    //Set flag
    flag_force_ready = 0;
    flag_image_ready = 1;
    flag_start_training = 1;

    printf("It will take %5.2f minuntes.\n", current_training.max_count *0.5/60.0);

    //Set a timer for training recording
    Fl::add_timeout(1.0/TRAINING_FREQUENCY, trainingRecord, NULL);
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%% All together Seperate %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Fl_Group *all_together=(Fl_Group *)0;

ImageDisplay *image_display_m=(ImageDisplay *)0;

Fl_Input *training_file_name=(Fl_Input *)0;

Fl_Progress *training_progress=(Fl_Progress *)0;

Fl_Check_Button *check_calibrate_thumb=(Fl_Check_Button *)0;

static void cb_check_calibrate_thumb(Fl_Check_Button*, void*) {
  // Make sure the "separate" checkbox is synchronized with this one
    if (check_calibrate_thumb->value())
    {
        check_calibrate_thumb_separate->set();
        flag_thumb = true;
        desired_force_x->value(1.0);
        desired_force_x->maximum(10.0);
        desired_force_x->minimum(0.0);
        desired_force_z->value(0.0);
        desired_force_z->maximum(-5.0);
        desired_force_z->minimum(5.0);
        maglev_m.desired_force[0] = 1.0;
        maglev_m.desired_force[2] = 0.0;
    }
    else
    {
        check_calibrate_thumb_separate->clear();
        flag_thumb = false;
        desired_force_x->value(0.0);
        desired_force_x->maximum(-5.0);
        desired_force_x->minimum(5.0);
        desired_force_z->value(-1.0);
        desired_force_z->maximum(-10.0);
        desired_force_z->minimum(0.0);
        maglev_m.desired_force[0] = 0.0;
        maglev_m.desired_force[2] = -1.0;
    };
}

Fl_Button *button_maglev_connect=(Fl_Button *)0;

static void cb_button_maglev_connect(Fl_Button*, void*) {
  // Check the current state of the Maglev
    if (maglev_m.flag_maglev_start)
    {
        // Synchronize the buttons
        button_maglev_connect_separate->clear();
        button_maglev_connect->clear();
        
        if ( button_maglev_lift_land -> value() )
        {
                button_maglev_lift_land_separate->clear();
                button_maglev_lift_land->clear();
                maglev_m.maglevLand (  );
        }
        maglev_m.maglevTurnOff ( );
        check_calibrate_thumb->activate();
        check_calibrate_thumb_separate->activate();
    }
    else
    {
        // Synchronize the buttons
        button_maglev_connect_separate->set();
        button_maglev_connect->set();
        
        // Start the force sensor
        force_sensor_m.startForceSensor();
        
        // Turn on the "draw force reading" callback
        Fl::add_timeout(1.0/FORCE_FREQUENCY, forceSensorReading);
        display_force->flag_force_display = true;
        
        // Connect to the Maglev
        maglev_m.maglevConnect (  );
        
        // Deactivate the Thumb Calibration checkbox
        check_calibrate_thumb->deactivate();
        check_calibrate_thumb_separate->deactivate();
        
        // Turn on the "draw maglev position" callback
        Fl::add_timeout(1.0/MAGLEV_FREQUENCY, maglevPositionReading);
        box_maglev_position->flag_maglev_position = true;
        box_maglev_rotation->flag_rotation_display = true;
    };
}

Fl_Button *button_maglev_lift_land=(Fl_Button *)0;

static void cb_button_maglev_lift_land(Fl_Button*, void*) {
  // Make sure the "separate" button is synchronized this one
    if (button_maglev_lift_land->value())
    {
        // Synchronize the "separate" button on the maglev_control tab
        button_maglev_lift_land_separate->set();
        
        // Have the Maglev take off
        maglev_m.maglevTakeOff ( flag_thumb );
        
        // Set the values of the gain sliders
        maglev_m.maglevGetInternalGains();
        position_gain_x_P->value(maglev_m.current_internal_gains[0][0]);
        position_gain_x_I->value(maglev_m.current_internal_gains[0][1]);
        position_gain_x_D->value(maglev_m.current_internal_gains[0][2]);
        
        position_gain_y_P->value(maglev_m.current_internal_gains[1][0]);
        position_gain_y_I->value(maglev_m.current_internal_gains[1][1]);
        position_gain_y_D->value(maglev_m.current_internal_gains[1][2]);
        
        position_gain_z_P->value(maglev_m.current_internal_gains[2][0]);
        position_gain_z_I->value(maglev_m.current_internal_gains[2][1]);
        position_gain_z_D->value(maglev_m.current_internal_gains[2][2]);
        
        rotation_gain_x_P->value(maglev_m.current_internal_gains[3][0]);
        rotation_gain_x_I->value(maglev_m.current_internal_gains[3][1]);
        rotation_gain_x_D->value(maglev_m.current_internal_gains[3][2]);
        
        rotation_gain_y_P->value(maglev_m.current_internal_gains[4][0]);
        rotation_gain_y_I->value(maglev_m.current_internal_gains[4][1]);
        rotation_gain_y_D->value(maglev_m.current_internal_gains[4][2]);
        
        rotation_gain_z_P->value(maglev_m.current_internal_gains[5][0]);
        rotation_gain_z_I->value(maglev_m.current_internal_gains[5][1]);
        rotation_gain_z_D->value(maglev_m.current_internal_gains[5][2]);
        
        // Set the Frequency slider
        slider_maglev_frequency->value(maglev_m.maglevGetFrequency( ));
    }
    else
    {
        // Synchronize the "separate" button on the maglev_control tab
        button_maglev_lift_land_separate->clear();
        
        // Land the Maglev
        maglev_m.maglevLand (  );
    };
}

Fl_Button *button_start_camera=(Fl_Button *)0;

static void cb_button_start_camera(Fl_Button*, void*) {
  if (button_start_camera->value())
    {
        // Make sure the "separate" button on the camera_control tab is synchronized
        button_start_camera_separate->set();
        
        // Start the camera
        camera_m.initCamera();
        camera_m.startCamera();
        
        // Determine the size of the camera images and allocate memory for an image
        int cols = camera_m.num_cols;
        int rows = camera_m.num_rows;
        int inc = camera_m.num_colors;
        unsigned char temp_image[cols*rows*inc];
        
        // Get a new image from the camera
        camera_m.grabImage();
        camera_m.getImage( temp_image );
        
        // Write the image to the image buffer
        image_buff.writeImage( rows, cols, inc, temp_image );
        
        //Set the timers for taking new images and displaying them
        Fl::add_timeout(1.0/CAMERA_FREQUENCY, takeImage, NULL);
        Fl::add_timeout(1.0/CAMERA_FREQUENCY, displayImage, NULL);
        
        // Set the "camera on" flag
        flag_camera_on = 1;
    }
    else
    {
        // Make sure the "separate" button on the camera_control tab is synchronized
        button_start_camera_separate->clear();
        
        // Turn the camera off
        Fl::remove_timeout(takeImage, NULL);
        Fl::remove_timeout(displayImage, NULL);
        flag_camera_on = 0;
        
        // Wait for the last callback to run
        Fl::wait(3);
        
        // Remove the camera handles
        camera_m.turnOffCamera();
    };
}

Fl_Button *choose_trajectory_file=(Fl_Button *)0;

static void cb_choose_trajectory_file(Fl_Button*, void*) {
  /*training_browser->load(".", 1);


    training_file_name->value( training_browser->text(training_browser->value()) );
    */
    Fl_File_Chooser* fc = new Fl_File_Chooser("./trajGen","Text Files (*.{txt,dat,tex})",Fl_File_Chooser::SINGLE,"Text File");
    fc->callback(fileChooserCallback);
    fc->show();
}

Fl_Button *read_trajectory_file=(Fl_Button *)0;

static void cb_read_trajectory_file(Fl_Button*, void*) {
  //Load the training trajectory from the file

    //Check if the file name is valid
    char filename[100];
    sprintf(filename, "%s", training_file_name->value());
    //File open
    current_training.ReadTrajectoryFile(filename);
}

Fl_Button *start_force_controller=(Fl_Button *)0;

static void cb_start_force_controller(Fl_Button*, void*) {
  // Determine whether the external controller is running
    if (maglev_m.flag_force_control_start)
    {
        // Synchronize both buttons -- Shutting off the external controller
        start_force_controller->clear();
        start_force_controller_separate->clear();
        
        // Stop the force controller
        maglev_m.maglevStopForceController();
        
        ///////////////////////////////////////////////////////////////////////////
        // Set the position control sliders to the values of the position gains
        ///////////////////////////////////////////////////////////////////////////
        
        // x-direction position gains
        position_gain_x_P->value(maglev_m.current_internal_gains[0][0]);
        position_gain_x_I->value(maglev_m.current_internal_gains[0][1]);
        position_gain_x_D->value(maglev_m.current_internal_gains[0][2]);
        
        // y-direction position gains
        position_gain_y_P->value(maglev_m.current_internal_gains[1][0]);
        position_gain_y_I->value(maglev_m.current_internal_gains[1][1]);
        position_gain_y_D->value(maglev_m.current_internal_gains[1][2]);
        
        // z-direction position gains
        position_gain_z_P->value(maglev_m.current_internal_gains[2][0]);
        position_gain_z_I->value(maglev_m.current_internal_gains[2][1]);
        position_gain_z_D->value(maglev_m.current_internal_gains[2][2]);
        
        // x-direction rotation gains
        rotation_gain_x_P->value(maglev_m.current_internal_gains[3][0]);
        rotation_gain_x_I->value(maglev_m.current_internal_gains[3][1]);
        rotation_gain_x_D->value(maglev_m.current_internal_gains[3][2]);
        
        // y-direction rotation gains
        rotation_gain_y_P->value(maglev_m.current_internal_gains[4][0]);
        rotation_gain_y_I->value(maglev_m.current_internal_gains[4][1]);
        rotation_gain_y_D->value(maglev_m.current_internal_gains[4][2]);
        
        // z-direction rotation gains
        rotation_gain_z_P->value(maglev_m.current_internal_gains[5][0]);
        rotation_gain_z_I->value(maglev_m.current_internal_gains[5][1]);
        rotation_gain_z_D->value(maglev_m.current_internal_gains[5][2]);
    }
    else if(maglev_m.flag_maglev_start && force_sensor_m.flag_force_sensor)
    {
        // Synchronize both buttons -- Turning on the external controller
        start_force_controller->set();
        start_force_controller_separate->set();
        
        // Start the force controller
	maglev_m.maglevStartForceController();
    printf("HERE\n");
	
	///////////////////////////////////////////////////////////////////////////
	// Set the force control sliders to the values of the force gains
	///////////////////////////////////////////////////////////////////////////
	
	// x-direction force gains
	force_gain_x_P->value(maglev_m.current_force_gains[0][0]);
	force_gain_x_I->value(maglev_m.current_force_gains[0][1]);
	force_gain_x_D->value(maglev_m.current_force_gains[0][2]);
	
	// y-direction force gains
	force_gain_y_P->value(maglev_m.current_force_gains[1][0]);
	force_gain_y_I->value(maglev_m.current_force_gains[1][1]);
	force_gain_y_D->value(maglev_m.current_force_gains[1][2]);
	
	// z-direction force gains
	force_gain_z_P->value(maglev_m.current_force_gains[2][0]);
	force_gain_z_I->value(maglev_m.current_force_gains[2][1]);
	force_gain_z_D->value(maglev_m.current_force_gains[2][2]);
	
	///////////////////////////////////////////////////////////////////////////
	// Set the position control sliders to the values of the position gains
	///////////////////////////////////////////////////////////////////////////
	
	// x-direction position gains
	position_gain_x_P->value(maglev_m.current_position_gains[0][0]);
	position_gain_x_I->value(maglev_m.current_position_gains[0][1]);
	position_gain_x_D->value(maglev_m.current_position_gains[0][2]);
	
	// y-direction position gains
	position_gain_y_P->value(maglev_m.current_position_gains[1][0]);
	position_gain_y_I->value(maglev_m.current_position_gains[1][1]);
	position_gain_y_D->value(maglev_m.current_position_gains[1][2]);
	
	// z-direction position gains
	position_gain_z_P->value(maglev_m.current_position_gains[2][0]);
	position_gain_z_I->value(maglev_m.current_position_gains[2][1]);
	position_gain_z_D->value(maglev_m.current_position_gains[2][2]);
	
	// x-direction rotation gains
	rotation_gain_x_P->value(maglev_m.current_position_gains[3][0]);
	rotation_gain_x_I->value(maglev_m.current_position_gains[3][1]);
	rotation_gain_x_D->value(maglev_m.current_position_gains[3][2]);
	
	// y-direction rotation gains
	rotation_gain_y_P->value(maglev_m.current_position_gains[4][0]);
	rotation_gain_y_I->value(maglev_m.current_position_gains[4][1]);
	rotation_gain_y_D->value(maglev_m.current_position_gains[4][2]);
	
	// z-direction rotation gains
	rotation_gain_z_P->value(maglev_m.current_position_gains[5][0]);
	rotation_gain_z_I->value(maglev_m.current_position_gains[5][1]);
	rotation_gain_z_D->value(maglev_m.current_position_gains[5][2]);
    }
    else
    {
        // Synchronize both buttons -- The external controller will not be running
        start_force_controller->clear();
        start_force_controller_separate->clear();
        
        // Explain to the user why the external force controller is not going to start
        printf("Cannot start the external controller:\n");
        if (!maglev_m.flag_maglev_start)
        {
                printf("\tThe Maglev is not on!\n");
        }
        if (!force_sensor_m.flag_force_sensor)
        {
                printf("\tThe force sensor is not on!\n");
        }
    };
}

Fl_Button *start_training=(Fl_Button *)0;

static void cb_start_training(Fl_Button*, void*) {
  //Check other things are ready
    //Camera

    if(access(data_dir,F_OK))
    {
	  printf("===========================\nThe data directory does not exist...creating it!\n===========================\n");
	  int error = mkdir(data_dir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
	  if(error == -1 )
	  {
		  printf("Got an error!\n");
	  }
    }

    if ( flag_camera_on == 0 || start_force_controller->value() == 0 
	|| current_training.flag_trajectory_ready == 0)
    {
	printf("Please turn on the controller and start the camera!\n");
	current_training.current_count = 0;
    //	return;
    }

    //Set flag
    flag_force_ready = 0;
    flag_image_ready = 1;
    flag_start_training = 1;

    printf("It will take %5.2f minutes.\n", current_training.max_count *0.5/60.0);

    //Set a timer for training recording
    Fl::add_timeout(1.0/TRAINING_FREQUENCY, trainingRecord, NULL);
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void force_control_parameter_update(Fl_Widget *o, void *)
{
  //printf("x->P = %g \n", force_gain_x_P->value());
  //display_force->size = force_gain_x_P->value();
  display_force->height_x = force_gain_x_P->value();
  display_force->height_y = force_gain_x_I->value();
  display_force->height_z = force_gain_x_D->value();
  display_force->redraw();
  printf("Setting force x height = (%5.2f | %5.2f)\n", force_gain_x_P->value(), display_force->height_x);
}

void position_control_parameter_update(Fl_Widget *o, void *)
{
  if (maglev_m.flag_maglev_start)
  {
    if (maglev_m.flag_force_control_start)
    {
      // Set the values for the x-position axis
      maglev_m.current_position_gains[0][0] = position_gain_x_P->value();
      maglev_m.current_position_gains[0][1] = position_gain_x_I->value();
      maglev_m.current_position_gains[0][2] = position_gain_x_D->value();

      // Set the values for the y-position axis
      maglev_m.current_position_gains[1][0] = position_gain_y_P->value();
      maglev_m.current_position_gains[1][1] = position_gain_y_I->value();
      maglev_m.current_position_gains[1][2] = position_gain_y_D->value();

      // Set the values for the z-position axis
      maglev_m.current_position_gains[2][0] = position_gain_z_P->value();
      maglev_m.current_position_gains[2][1] = position_gain_z_I->value();
      maglev_m.current_position_gains[2][2] = position_gain_z_D->value();

      // Set the values for the x-rotation axis
      maglev_m.current_position_gains[3][0] = rotation_gain_x_P->value();
      maglev_m.current_position_gains[3][1] = rotation_gain_x_I->value();
      maglev_m.current_position_gains[3][2] = rotation_gain_x_D->value();

      // Set the values for the y-rotation axis
      maglev_m.current_position_gains[4][0] = rotation_gain_y_P->value();
      maglev_m.current_position_gains[4][1] = rotation_gain_y_I->value();
      maglev_m.current_position_gains[4][2] = rotation_gain_y_D->value();

      // Set the values for the z-rotation axis
      maglev_m.current_position_gains[5][0] = rotation_gain_z_P->value();
      maglev_m.current_position_gains[5][1] = rotation_gain_z_I->value();
      maglev_m.current_position_gains[5][2] = rotation_gain_z_D->value();
    }
    else
    {
      // Set the values for the x-position axis
      maglev_m.current_internal_gains[0][0] = position_gain_x_P->value();
      maglev_m.current_internal_gains[0][1] = position_gain_x_I->value();
      maglev_m.current_internal_gains[0][2] = position_gain_x_D->value();

      // Set the values for the y-position axis
      maglev_m.current_internal_gains[1][0] = position_gain_y_P->value();
      maglev_m.current_internal_gains[1][1] = position_gain_y_I->value();
      maglev_m.current_internal_gains[1][2] = position_gain_y_D->value();

      // Set the values for the z-position axis
      maglev_m.current_internal_gains[2][0] = position_gain_z_P->value();
      maglev_m.current_internal_gains[2][1] = position_gain_z_I->value();
      maglev_m.current_internal_gains[2][2] = position_gain_z_D->value();

      // Set the values for the x-rotation axis
      maglev_m.current_internal_gains[3][0] = rotation_gain_x_P->value();
      maglev_m.current_internal_gains[3][1] = rotation_gain_x_I->value();
      maglev_m.current_internal_gains[3][2] = rotation_gain_x_D->value();

      // Set the values for the y-rotation axis
      maglev_m.current_internal_gains[4][0] = rotation_gain_y_P->value();
      maglev_m.current_internal_gains[4][1] = rotation_gain_y_I->value();
      maglev_m.current_internal_gains[4][2] = rotation_gain_y_D->value();

      // Set the values for the z-rotation axis
      maglev_m.current_internal_gains[5][0] = rotation_gain_z_P->value();
      maglev_m.current_internal_gains[5][1] = rotation_gain_z_I->value();
      maglev_m.current_internal_gains[5][2] = rotation_gain_z_D->value();

      // Set the Maglev's internal gains to the new values
      maglev_m.maglevSetInternalGains();
    }
  }
}
ForceSensor force_sensor_m;

void forceSensorReading(void *)
{
  if (display_force->flag_force_display)
  {
    // Read a new set of data from the force sensor
    force_sensor_m.readNewData();

    // Set the height of the bars in the force display
    display_force->height_x = force_sensor_m.curr_force.force[0];
    display_force->height_y = force_sensor_m.curr_force.force[1];
    display_force->height_z = force_sensor_m.curr_force.force[2];
    display_force->redraw();
    //printf("%5.2f | %5.2f | %5.2f\n", force_sensor_m.curr_force.time, force_sensor_m.curr_force.force[0], display_force->height_x);
  }
  //printf("Reading the force (%10.6f | %10.6f | %10.6f)\n", force_sensor_m.curr_force.time, force_sensor_m.curr_force.force[2], display_force->height_z);

  // Set up the next iteration of this timer
  Fl::repeat_timeout(1.0 / FORCE_FREQUENCY, forceSensorReading);
}
MaglevControl maglev_m;

int tick_callback_handler(ml_device_handle_t device_handler, ml_position_t *maglev_position)
{
  // If displaying force, read the force data
  if (display_force->flag_force_display)
  {
    force_sensor_m.readNewData();
  }

  // Baggza - We might be able to move this into the trainingRecord timer to improve speed
  // I would also like to be able to add position trajectories to this eventually
  if (flag_start_training && !flag_force_ready)
  {
    // If the force sensor is on and a training trajectory is active, update
    //   the desired force using the "ramp-and-hold"
    static float new_force[6];
    static float old_force[6];

    // Determine where the timing is in the "ramp-and-hold" trajectory
    if (current_training.ramp_count == 0)
    {
      // Starting at the beginning of the ramp

      // Process each force direction to determine the new and old forces
      printf("Moving to new force level: (");
      for (int i = 0; i < 6; i++)
      {
        if (maglev_m.force_control_directions[i])
        {
          // Read the new force from the trajectory array
          new_force[i] = current_training.traj[i][current_training.current_count];
          printf("%5.2f", new_force[i]);

          // If at the beginning of the trajectory, the old force is the current force.
          //   Otherwise, it is the previous force in the trajectory array.
          if (current_training.current_count == 0)
          {
            old_force[i] = force_sensor_m.curr_force.force[i];
          }
          else
          {
            old_force[i] = current_training.traj[i][current_training.current_count - 1];
          }
        }
        else
        {
          // Read the new force from the trajectory array
          new_force[i] = current_training.traj[i][current_training.current_count];
          printf("%6.3f", new_force[i]);

          // If at the beginning of the trajectory, the old force is the current force.
          //   Otherwise, it is the previous force in the trajectory array.
          if (current_training.current_count == 0)
          {
            old_force[i] = maglev_m.current_position[i];
          }
          else
          {
            old_force[i] = current_training.traj[i][current_training.current_count - 1];
          }
        }
      }
      printf(")\n");
    }
    if (current_training.ramp_count < current_training.ramp_max && flag_image_ready == 1)
    {
      // The imager is ready, so the force can changes
      for (int i = 0; i < 6; i++)
      {
        float interpolation_constant = ((float)current_training.ramp_count) / ((float)current_training.ramp_max);
        if (maglev_m.force_control_directions[i])
        {
          maglev_m.desired_force[i] = (new_force[i] - old_force[i]) * interpolation_constant + old_force[i];
        }
        else
        {
          maglev_m.desired_position[i] = (new_force[i] - old_force[i]) * interpolation_constant + old_force[i];
        }
      }
      current_training.ramp_count += 1;
    }
    else if (current_training.ramp_count < current_training.ramp_max + current_training.hold_min && flag_image_ready == 1)
    {
      for (int i = 0; i < 6; i++)
      {
        if (maglev_m.force_control_directions[i])
        {
          maglev_m.desired_force[i] = new_force[i];
        }
        else
        {
          maglev_m.desired_position[i] = new_force[i];
        }
      }
      current_training.ramp_count += 1;
    }
    else if (current_training.ramp_count == (current_training.ramp_max + current_training.hold_min))
    {
      //The force is ready
      flag_force_ready = 1;
      current_training.ramp_count = 0;
    }
    //std::cout << maglev_m.desired_force[0] << " " << maglev_m.desired_force[1] << " "<< maglev_m.desired_force[2] <<"\n";

  } //*/

  // Run the Maglev Controller
  maglev_m.maglevController(force_sensor_m.curr_force);
  return 0;
}

void maglevPositionReading(void *)
{
  //printf("I am");
  if (maglev_m.flag_maglev_start)
  {
    if (!maglev_m.flag_force_control_start)
    {
      // If the Force-to-Position controller is off, update the position manually
      maglev_m.maglevGetPosition();
    }
    box_maglev_position->set3DAxis(maglev_m.current_position);
    box_maglev_position->redraw();
  }
  /*else
    {
            printf(" NOT");
    }
    printf(" updating the Maglev position display.\n");//*/
  if (box_maglev_rotation->flag_rotation_display)
  {
    // Set the height of the bars in the force display
    box_maglev_rotation->height_x = maglev_m.current_position[3];
    box_maglev_rotation->height_y = maglev_m.current_position[4];
    box_maglev_rotation->height_z = maglev_m.current_position[5];
    box_maglev_rotation->redraw();
  }
  Fl::repeat_timeout(1.0 / MAGLEV_FREQUENCY, maglevPositionReading);
}

void demo_callback(void *)
{
  char file[100];
  sprintf(file, "%smonitor_linux &", demo_dir);
  system(file);
}

void displayImage(void *)
{
  //Display the image
  int cols = image_buff.cols;
  int rows = image_buff.rows;
  int inc = image_buff.inc;
  unsigned char temp_image[cols * rows * inc];
  image_buff.readImage(temp_image);
  // printf("Image res is cols=%d, rows=%d, inc= %d \n",cols, rows, inc);
  image_display_m->readImage(temp_image, cols, rows, inc);
  image_display_m->redraw();
  image_display_b->readImage(temp_image, cols, rows, inc);
  image_display_b->redraw();
  Fl::repeat_timeout(1.0 / CAMERA_FREQUENCY, displayImage, NULL);
}

void takeImage(void *)
{
  if (flag_camera_on)
  { //take a new image image
    int cols = camera_m.num_cols;
    int rows = camera_m.num_rows;
    int inc = camera_m.num_colors;
    unsigned char temp_image[cols * rows * inc];
    camera_m.grabImage();
    camera_m.getImage(temp_image);
    image_buff.writeImage(temp_image);

    Fl::repeat_timeout(1.0 / CAMERA_FREQUENCY, takeImage, NULL);
  }
}

void fileChooserCallback(Fl_File_Chooser *o, void *v)
{
  //printf("Chose %s!\n", o -> value());
  training_file_name->value(o->value());
  training_file_name_separate->value(o->value());
}

void trainingRecord(void *)
{
  //Record training results

  static int counter = 0;
  //if ( flag_training_record )
  if (flag_force_ready)
  {
    printf("The force is ready\n");
    //First take the force reading
    float curr_force[6];
    for (int i = 0; i < 6; i++)
    {
      curr_force[i] = (float)force_sensor_m.curr_force.force[i];
    }

    //Then take the image
    int cols = image_buff.cols;
    int rows = image_buff.rows;
    int inc = image_buff.inc;
    unsigned char temp_image[cols * rows * inc];
    image_buff.readImage(temp_image);

    //Clear the flag so that the controller can go forward
    current_training.current_count += 1;
    //Set the flag so that the force controller can go to next desired force
    flag_force_ready = 0;
    flag_image_ready = 1;
    printf("Image is ready to save\n");

    //Save the force into the image
    // Fx, Fy are assumed to lie in [-6 N, +6 N] while Fz
    // lies in [-1 N, 11 N].  Thus the total range is the same
    // but with a different offset.  Both of these ranges are
    // mapped to the pixel range [0, 255].  Since at this time
    // we actually don't intend to go beyond a 10 N range for
    // any of the directions, there is some wasted space, but
    // this should catch any data in a reasonable range outside
    // that desired range.  This will give an accuracy of up to
    // 0.05 N in any direction.
    temp_image[0] = floor(21.25 * (curr_force[0] + 6));
    temp_image[1] = floor(21.25 * (curr_force[1] + 6));
    temp_image[2] = floor(21.25 * (curr_force[2] + 1));

    //Torque, need to find out the range of the torques
    // These just give an approximation for the torques.  Until
    // we determine a reasonable range of torques, there's no
    // point in finding a better conversion formula.
    temp_image[3] = floor(curr_force[3] * 10.0 + 100.0);
    temp_image[4] = floor(curr_force[4] * 10.0 + 100.0);
    temp_image[5] = floor(curr_force[5] * 10.0 + 100.0);

    //Save image to a filename
    char filename[100];
    sprintf(filename, "%s%d.ppm", data_dir, current_training.current_count);
    ppm_write(filename, cols, rows, temp_image);

    //Keep counting
    //Update the progress
    float temp_t = ((float)current_training.current_count) / ((float)current_training.max_count) * 100.0;
    training_progress->value(temp_t);
    printf("Progress -- %6.2f%%\n", training_progress->value());

    if (current_training.current_count >= current_training.max_count)
    {
      printf("The training is done\n");
      flag_start_training = 0;
      return;
    }
  }

  //std::cout << "HERE\n";
  Fl::repeat_timeout(1.0 / TRAINING_FREQUENCY, trainingRecord, NULL);
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%% Main Loop %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Fl_Double_Window *PopupCameraWindow=(Fl_Double_Window *)0;

int main() {
  { control_window = new Fl_Double_Window(900, 650, "Maglev Imaging Calibration System");
    { box_maglev_rotation = new Plot2DView(10, 10, 260, 100, "Maglev Position");
      box_maglev_rotation->box(FL_ENGRAVED_BOX);
      box_maglev_rotation->color((Fl_Color)FL_BACKGROUND_COLOR);
      box_maglev_rotation->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
      box_maglev_rotation->labeltype(FL_NORMAL_LABEL);
      box_maglev_rotation->labelfont(0);
      box_maglev_rotation->labelsize(14);
      box_maglev_rotation->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
      box_maglev_rotation->align(FL_ALIGN_BOTTOM);
      box_maglev_rotation->when(FL_WHEN_RELEASE);
    } // Plot2DView* box_maglev_rotation
    { box_maglev_position = new Graph3DAxis(10, 120, 260, 260, "Maglev Position");
      box_maglev_position->box(FL_ENGRAVED_BOX);
      box_maglev_position->color((Fl_Color)FL_BACKGROUND_COLOR);
      box_maglev_position->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
      box_maglev_position->labeltype(FL_NORMAL_LABEL);
      box_maglev_position->labelfont(0);
      box_maglev_position->labelsize(14);
      box_maglev_position->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
      box_maglev_position->align(FL_ALIGN_TOP);
      box_maglev_position->when(FL_WHEN_RELEASE);
    } // Graph3DAxis* box_maglev_position
    { display_force = new CubeView(10, 385, 260, 260, "Display Force");
      display_force->box(FL_ENGRAVED_BOX);
      display_force->color((Fl_Color)FL_BACKGROUND_COLOR);
      display_force->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
      display_force->labeltype(FL_NORMAL_LABEL);
      display_force->labelfont(0);
      display_force->labelsize(14);
      display_force->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
      display_force->align(FL_ALIGN_BOTTOM);
      display_force->when(FL_WHEN_RELEASE);
    } // CubeView* display_force
    { Fl_Tabs* o = new Fl_Tabs(275, 20, 620, 625);
      { maglev_position = new Fl_Group(280, 55, 600, 590, "Maglev");
        { position_gain_sliders = new Fl_Group(280, 80, 470, 478, "Position Control PID Gains");
          position_gain_sliders->box(FL_BORDER_FRAME);
          position_gain_sliders->color((Fl_Color)34);
          { position_gain_sliders_x = new Fl_Group(285, 97, 130, 200, "x-direction");
            { position_gain_x_P = new Fl_Value_Slider(285, 97, 30, 200, "Kp");
              position_gain_x_P->minimum(7000);
              position_gain_x_P->maximum(0);
              position_gain_x_P->step(500);
              position_gain_x_P->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* position_gain_x_P
            { position_gain_x_I = new Fl_Value_Slider(330, 97, 30, 200, "Ki");
              position_gain_x_I->minimum(100);
              position_gain_x_I->maximum(0);
              position_gain_x_I->step(5);
              position_gain_x_I->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* position_gain_x_I
            { position_gain_x_D = new Fl_Value_Slider(375, 97, 30, 200, "Kd");
              position_gain_x_D->minimum(500);
              position_gain_x_D->maximum(0);
              position_gain_x_D->step(10);
              position_gain_x_D->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* position_gain_x_D
            position_gain_sliders_x->end();
          } // Fl_Group* position_gain_sliders_x    control_window->end();

          { position_gain_sliders_y = new Fl_Group(450, 97, 130, 200, "y-direction");
            { position_gain_y_P = new Fl_Value_Slider(450, 97, 30, 200, "Kp");
              position_gain_y_P->minimum(7000);
              position_gain_y_P->maximum(0);
              position_gain_y_P->step(500);
              position_gain_y_P->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* position_gain_y_P
            { position_gain_y_I = new Fl_Value_Slider(495, 97, 30, 200, "Ki");
              position_gain_y_I->minimum(100);
              position_gain_y_I->maximum(0);
              position_gain_y_I->step(5);
              position_gain_y_I->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* position_gain_y_I
            { position_gain_y_D = new Fl_Value_Slider(545, 97, 30, 200, "Kd");
              position_gain_y_D->minimum(500);
              position_gain_y_D->maximum(0);
              position_gain_y_D->step(10);
              position_gain_y_D->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* position_gain_y_D
            position_gain_sliders_y->end();
          } // Fl_Group* position_gain_sliders_y
          { position_gain_sliders_z = new Fl_Group(615, 97, 130, 200, "z-direction");
            { position_gain_z_P = new Fl_Value_Slider(615, 97, 30, 200, "Kp");
              position_gain_z_P->minimum(10000);
              position_gain_z_P->maximum(0);
              position_gain_z_P->step(500);
              position_gain_z_P->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* position_gain_z_P
            { position_gain_z_I = new Fl_Value_Slider(660, 97, 30, 200, "Ki");
              position_gain_z_I->minimum(100);
              position_gain_z_I->maximum(0);
              position_gain_z_I->step(5);
              position_gain_z_I->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* position_gain_z_I
            { position_gain_z_D = new Fl_Value_Slider(705, 97, 30, 200, "Kd");
              position_gain_z_D->minimum(500);
              position_gain_z_D->maximum(0);
              position_gain_z_D->step(10);
              position_gain_z_D->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* position_gain_z_D
            position_gain_sliders_z->end();
          } // Fl_Group* position_gain_sliders_z
          { rotation_gain_sliders_x = new Fl_Group(285, 333, 130, 200, "x-rotation");
            { rotation_gain_x_P = new Fl_Value_Slider(285, 333, 30, 200, "Kp");
              rotation_gain_x_P->minimum(10000);
              rotation_gain_x_P->maximum(0);
              rotation_gain_x_P->step(500);
              rotation_gain_x_P->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* rotation_gain_x_P
            { rotation_gain_x_I = new Fl_Value_Slider(330, 333, 30, 200, "Ki");
              rotation_gain_x_I->minimum(5000);
              rotation_gain_x_I->maximum(0);
              rotation_gain_x_I->step(100);
              rotation_gain_x_I->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* rotation_gain_x_I
            { rotation_gain_x_D = new Fl_Value_Slider(375, 333, 30, 200, "Kd");
              rotation_gain_x_D->minimum(500);
              rotation_gain_x_D->maximum(0);
              rotation_gain_x_D->step(50);
              rotation_gain_x_D->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* rotation_gain_x_D
            rotation_gain_sliders_x->end();
          } // Fl_Group* rotation_gain_sliders_x
          { rotation_gain_sliders_y = new Fl_Group(450, 333, 130, 200, "y-rotation");
            { rotation_gain_y_P = new Fl_Value_Slider(450, 333, 30, 200, "Kp");
              rotation_gain_y_P->minimum(10000);
              rotation_gain_y_P->maximum(0);
              rotation_gain_y_P->step(500);
              rotation_gain_y_P->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* rotation_gain_y_P
            { rotation_gain_y_I = new Fl_Value_Slider(495, 333, 30, 200, "Ki");
              rotation_gain_y_I->minimum(5000);
              rotation_gain_y_I->maximum(0);
              rotation_gain_y_I->step(100);
              rotation_gain_y_I->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* rotation_gain_y_I
            { rotation_gain_y_D = new Fl_Value_Slider(540, 333, 30, 200, "Kd");
              rotation_gain_y_D->minimum(500);
              rotation_gain_y_D->maximum(0);
              rotation_gain_y_D->step(50);
              rotation_gain_y_D->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* rotation_gain_y_D
            rotation_gain_sliders_y->end();
          } // Fl_Group* rotation_gain_sliders_y
          { rotation_gain_sliders_z = new Fl_Group(615, 333, 130, 200, "z-rotation");
            { rotation_gain_z_P = new Fl_Value_Slider(615, 333, 30, 200, "Kp");
              rotation_gain_z_P->minimum(10000);
              rotation_gain_z_P->maximum(0);
              rotation_gain_z_P->step(500);
              rotation_gain_z_P->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* rotation_gain_z_P
            { rotation_gain_z_I = new Fl_Value_Slider(660, 333, 30, 200, "Ki");
              rotation_gain_z_I->minimum(10000);
              rotation_gain_z_I->maximum(0);
              rotation_gain_z_I->step(500);
              rotation_gain_z_I->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* rotation_gain_z_I
            { rotation_gain_z_D = new Fl_Value_Slider(705, 333, 30, 200, "Kd");
              rotation_gain_z_D->minimum(1000);
              rotation_gain_z_D->maximum(0);
              rotation_gain_z_D->step(50);
              rotation_gain_z_D->callback((Fl_Callback*)position_control_parameter_update);
            } // Fl_Value_Slider* rotation_gain_z_D
            rotation_gain_sliders_z->end();
          } // Fl_Group* rotation_gain_sliders_z
          position_gain_sliders->end();
        } // Fl_Group* position_gain_sliders
        { button_maglev_connect_separate = new Fl_Button(280, 560, 80, 25, "Connect");
          button_maglev_connect_separate->type(1);
          button_maglev_connect_separate->callback((Fl_Callback*)cb_button_maglev_connect_separate);
        } // Fl_Button* button_maglev_connect_separate
        { button_maglev_lift_land_separate = new Fl_Button(280, 585, 80, 25, "Lift/Land");
          button_maglev_lift_land_separate->type(1);
          button_maglev_lift_land_separate->callback((Fl_Callback*)cb_button_maglev_lift_land_separate);
        } // Fl_Button* button_maglev_lift_land_separate
        { slider_maglev_frequency = new Fl_Value_Slider(285, 610, 130, 17, "Frequency");
          slider_maglev_frequency->type(1);
          slider_maglev_frequency->box(FL_BORDER_BOX);
          slider_maglev_frequency->color((Fl_Color)42);
          slider_maglev_frequency->selection_color((Fl_Color)FL_RED);
          slider_maglev_frequency->minimum(100);
          slider_maglev_frequency->maximum(1500);
          slider_maglev_frequency->step(10);
          slider_maglev_frequency->value(1000);
          slider_maglev_frequency->textsize(14);
          slider_maglev_frequency->callback((Fl_Callback*)cb_slider_maglev_frequency);
        } // Fl_Value_Slider* slider_maglev_frequency
        { check_calibrate_thumb_separate = new Fl_Check_Button(365, 575, 125, 18, "Thumb");
          check_calibrate_thumb_separate->down_box(FL_DOWN_BOX);
          check_calibrate_thumb_separate->callback((Fl_Callback*)cb_check_calibrate_thumb_separate);
        } // Fl_Check_Button* check_calibrate_thumb_separate
        { demo_buttons = new Fl_Group(480, 575, 400, 65);
          { Fl_Box* o = new Fl_Box(480, 575, 400, 65, "Demos");
            o->box(FL_ENGRAVED_FRAME);
            o->align(FL_ALIGN_TOP);
          } // Fl_Box* o
          { Fl_Button* o = new Fl_Button(490, 580, 120, 25, "Monitor");
            o->callback((Fl_Callback*)demo_callback);
          } // Fl_Button* o
          { Fl_Button* o = new Fl_Button(490, 610, 120, 25, "Sine Texture");
            o->callback((Fl_Callback*)cb_Sine);
          } // Fl_Button* o
          { Fl_Button* o = new Fl_Button(620, 580, 120, 25, "Sine Motion");
            o->callback((Fl_Callback*)cb_Sine1);
          } // Fl_Button* o
          { Fl_Button* o = new Fl_Button(620, 610, 120, 25, "Dither Texture");
            o->callback((Fl_Callback*)cb_Dither);
          } // Fl_Button* o
          { Fl_Button* o = new Fl_Button(750, 580, 120, 25, "Bunny");
            o->callback((Fl_Callback*)cb_Bunny);
          } // Fl_Button* o
          { Fl_Button* o = new Fl_Button(750, 610, 120, 25, "Cube");
            o->callback((Fl_Callback*)cb_Cube);
          } // Fl_Button* o
          demo_buttons->end();
        } // Fl_Group* demo_buttons
        maglev_position->end();
      } // Fl_Group* maglev_position
      { force_controller = new Fl_Group(280, 55, 600, 590, "Force Controller");
        force_controller->box(FL_FLAT_BOX);
        force_controller->hide();
        { force_gain_sliders = new Fl_Group(285, 80, 460, 385, "Force Control PID Gains");
          force_gain_sliders->box(FL_ENGRAVED_FRAME);
          { force_gain_sliders_x = new Fl_Group(290, 97, 120, 350, "x Force");
            { force_gain_x_P = new Fl_Value_Slider(290, 97, 30, 350, "Kp");
              force_gain_x_P->minimum(10);
              force_gain_x_P->maximum(0);
              force_gain_x_P->step(0.5);
              force_gain_x_P->callback((Fl_Callback*)cb_force_gain_x_P);
            } // Fl_Value_Slider* force_gain_x_P
            { force_gain_x_I = new Fl_Value_Slider(335, 97, 30, 350, "Ki");
              force_gain_x_I->minimum(100);
              force_gain_x_I->maximum(0);
              force_gain_x_I->step(5);
              force_gain_x_I->callback((Fl_Callback*)cb_force_gain_x_I);
            } // Fl_Value_Slider* force_gain_x_I
            { force_gain_x_D = new Fl_Value_Slider(380, 97, 30, 350, "Kd");
              force_gain_x_D->minimum(100);
              force_gain_x_D->maximum(0);
              force_gain_x_D->step(5);
              force_gain_x_D->callback((Fl_Callback*)cb_force_gain_x_D);
            } // Fl_Value_Slider* force_gain_x_D
            force_gain_sliders_x->end();
          } // Fl_Group* force_gain_sliders_x
          { force_gain_sliders_y = new Fl_Group(455, 97, 120, 350, "y Force");
            { force_gain_y_P = new Fl_Value_Slider(455, 97, 30, 350, "Kp");
              force_gain_y_P->minimum(10);
              force_gain_y_P->maximum(0);
              force_gain_y_P->step(0.5);
              force_gain_y_P->callback((Fl_Callback*)cb_force_gain_y_P);
            } // Fl_Value_Slider* force_gain_y_P
            { force_gain_y_I = new Fl_Value_Slider(500, 97, 30, 350, "Ki");
              force_gain_y_I->minimum(100);
              force_gain_y_I->maximum(0);
              force_gain_y_I->step(5);
              force_gain_y_I->callback((Fl_Callback*)cb_force_gain_y_I);
            } // Fl_Value_Slider* force_gain_y_I
            { force_gain_y_D = new Fl_Value_Slider(545, 97, 30, 350, "Kd");
              force_gain_y_D->minimum(100);
              force_gain_y_D->maximum(0);
              force_gain_y_D->step(5);
              force_gain_y_D->callback((Fl_Callback*)cb_force_gain_y_D);
            } // Fl_Value_Slider* force_gain_y_D
            force_gain_sliders_y->end();
          } // Fl_Group* force_gain_sliders_y
          { force_gain_sliders_z = new Fl_Group(620, 97, 120, 350, "z Force");
            { force_gain_z_P = new Fl_Value_Slider(620, 97, 30, 350, "Kp");
              force_gain_z_P->minimum(10);
              force_gain_z_P->maximum(0);
              force_gain_z_P->step(0.5);
              force_gain_z_P->callback((Fl_Callback*)cb_force_gain_z_P);
            } // Fl_Value_Slider* force_gain_z_P
            { force_gain_z_I = new Fl_Value_Slider(665, 97, 30, 350, "Ki");
              force_gain_z_I->minimum(100);
              force_gain_z_I->maximum(0);
              force_gain_z_I->step(5);
              force_gain_z_I->callback((Fl_Callback*)cb_force_gain_z_I);
            } // Fl_Value_Slider* force_gain_z_I
            { force_gain_z_D = new Fl_Value_Slider(710, 97, 30, 350, "Kd");
              force_gain_z_D->minimum(100);
              force_gain_z_D->maximum(0);
              force_gain_z_D->step(5);
              force_gain_z_D->callback((Fl_Callback*)cb_force_gain_z_D);
            } // Fl_Value_Slider* force_gain_z_D
            force_gain_sliders_z->end();
          } // Fl_Group* force_gain_sliders_z
          force_gain_sliders->end();
        } // Fl_Group* force_gain_sliders
        { target_forces = new Fl_Group(750, 80, 130, 200, "Desired Forces");
          target_forces->box(FL_ENGRAVED_FRAME);
          { desired_force_x = new Fl_Value_Slider(755, 85, 30, 175, "Fx");
            desired_force_x->minimum(5);
            desired_force_x->maximum(-5);
            desired_force_x->step(1);
            desired_force_x->callback((Fl_Callback*)cb_desired_force_x);
          } // Fl_Value_Slider* desired_force_x
          { desired_force_y = new Fl_Value_Slider(800, 85, 30, 175, "Fy");
            desired_force_y->minimum(5);
            desired_force_y->maximum(-5);
            desired_force_y->step(1);
            desired_force_y->callback((Fl_Callback*)cb_desired_force_y);
          } // Fl_Value_Slider* desired_force_y
          { desired_force_z = new Fl_Value_Slider(845, 85, 30, 175, "Fz");
            desired_force_z->maximum(-10);
            desired_force_z->step(1);
            desired_force_z->value(-1);
            desired_force_z->callback((Fl_Callback*)cb_desired_force_z);
          } // Fl_Value_Slider* desired_force_z
          target_forces->end();
        } // Fl_Group* target_forces
        { target_positions = new Fl_Group(750, 295, 130, 345, "Desired Positions");
          target_positions->box(FL_ENGRAVED_FRAME);
          { desired_position_x = new Fl_Value_Slider(755, 300, 30, 150, "x_p");
            desired_position_x->minimum(12);
            desired_position_x->maximum(-12);
            desired_position_x->step(1);
            desired_position_x->callback((Fl_Callback*)cb_desired_position_x);
          } // Fl_Value_Slider* desired_position_x
          { desired_position_y = new Fl_Value_Slider(800, 300, 30, 150, "y_p");
            desired_position_y->minimum(12);
            desired_position_y->maximum(-12);
            desired_position_y->step(1);
            desired_position_y->callback((Fl_Callback*)cb_desired_position_y);
          } // Fl_Value_Slider* desired_position_y
          { desired_position_z = new Fl_Value_Slider(845, 300, 30, 150, "z_p");
            desired_position_z->minimum(12);
            desired_position_z->maximum(-12);
            desired_position_z->step(1);
            desired_position_z->callback((Fl_Callback*)cb_desired_position_z);
          } // Fl_Value_Slider* desired_position_z
          { desired_rotation_x = new Fl_Value_Slider(755, 470, 30, 150, "x_r");
            desired_rotation_x->minimum(8);
            desired_rotation_x->maximum(-8);
            desired_rotation_x->step(1);
            desired_rotation_x->callback((Fl_Callback*)cb_desired_rotation_x);
          } // Fl_Value_Slider* desired_rotation_x
          { desired_rotation_y = new Fl_Value_Slider(800, 470, 30, 150, "y_r");
            desired_rotation_y->minimum(8);
            desired_rotation_y->maximum(-8);
            desired_rotation_y->step(1);
            desired_rotation_y->callback((Fl_Callback*)cb_desired_rotation_y);
          } // Fl_Value_Slider* desired_rotation_y
          { desired_rotation_z = new Fl_Value_Slider(845, 470, 30, 150, "z_r");
            desired_rotation_z->minimum(8);
            desired_rotation_z->maximum(-8);
            desired_rotation_z->step(1);
            desired_rotation_z->callback((Fl_Callback*)cb_desired_rotation_z);
          } // Fl_Value_Slider* desired_rotation_z
          target_positions->end();
        } // Fl_Group* target_positions
        { start_force_controller_separate = new Fl_Button(290, 470, 170, 25, "Start Force Controller");
          start_force_controller_separate->type(1);
          start_force_controller_separate->color((Fl_Color)FL_RED);
          start_force_controller_separate->selection_color((Fl_Color)2);
          start_force_controller_separate->callback((Fl_Callback*)cb_start_force_controller_separate);
        } // Fl_Button* start_force_controller_separate
        { Fl_Button* o = new Fl_Button(290, 495, 170, 25, "Save new gains");
          o->callback((Fl_Callback*)cb_Save);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(290, 520, 170, 25, "Save Force");
          o->callback((Fl_Callback*)cb_Save1);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(290, 545, 170, 25, "Stop Save");
          o->callback((Fl_Callback*)cb_Stop);
        } // Fl_Button* o
        { system_id = new Fl_Group(470, 485, 250, 140, "System Identification Parameters");
          system_id->box(FL_ENGRAVED_BOX);
          { slide_force_magnitude = new Fl_Value_Slider(480, 495, 200, 20, "Force Frequency Mantissa (a)");
            slide_force_magnitude->type(1);
            slide_force_magnitude->box(FL_BORDER_BOX);
            slide_force_magnitude->color((Fl_Color)42);
            slide_force_magnitude->selection_color((Fl_Color)FL_RED);
            slide_force_magnitude->minimum(0.1);
            slide_force_magnitude->maximum(0.9);
            slide_force_magnitude->step(0.1);
            slide_force_magnitude->value(0.1);
            slide_force_magnitude->textsize(14);
          } // Fl_Value_Slider* slide_force_magnitude
          { slide_force_power = new Fl_Value_Slider(480, 535, 200, 20, "Force Frequency Power (b)");
            slide_force_power->type(1);
            slide_force_power->box(FL_BORDER_BOX);
            slide_force_power->color((Fl_Color)42);
            slide_force_power->selection_color((Fl_Color)FL_RED);
            slide_force_power->minimum(-3);
            slide_force_power->maximum(3);
            slide_force_power->step(1);
            slide_force_power->textsize(14);
          } // Fl_Value_Slider* slide_force_power
          { force_frequency = new Fl_Text_Display(480, 585, 100, 20, "Frequency");
          } // Fl_Text_Display* force_frequency
          system_id->end();
        } // Fl_Group* system_id
        force_controller->end();
      } // Fl_Group* force_controller
      { camera_control = new Fl_Group(280, 55, 600, 590, "Camera Control");
        camera_control->box(FL_ENGRAVED_FRAME);
        camera_control->hide();
        { camera_settings = new Fl_Group(600, 80, 280, 362, "Camera Settings"); 
          camera_settings->box(FL_ENGRAVED_FRAME);
          { camera_brightness = new Fl_Value_Slider(609, 120, 180, 20, "Brightness");
            camera_brightness->type(1);
            camera_brightness->textsize(10);
            camera_brightness->align(FL_ALIGN_RIGHT);
          } // Fl_Value_Slider* camera_brightness
          { camera_exposure = new Fl_Value_Slider(609, 160, 180, 20, "Exposure");
            camera_exposure->type(1);
            camera_exposure->textsize(10);
            camera_exposure->align(FL_ALIGN_RIGHT);
          } // Fl_Value_Slider* camera_exposure
          { camera_gamma = new Fl_Value_Slider(609, 200, 180, 20, "Gamma");
            camera_gamma->type(1);
            camera_gamma->textsize(10);
            camera_gamma->align(FL_ALIGN_RIGHT);
          } // Fl_Value_Slider* camera_gamma
          { camera_shutter = new Fl_Value_Slider(609, 240, 180, 20, "Shutter");
            camera_shutter->type(1);
            camera_shutter->textsize(10);
            camera_shutter->align(FL_ALIGN_RIGHT);
          } // Fl_Value_Slider* camera_shutter
          { camera_framerate = new Fl_Value_Slider(609, 280, 180, 20, "Frame rate");
            camera_framerate->type(1);
            camera_framerate->textsize(10);
            camera_framerate->align(FL_ALIGN_RIGHT);
          } // Fl_Value_Slider* camera_framerate
          { camera_gain = new Fl_Value_Slider(609, 320, 180, 20, "Gain");
            camera_gain->type(1);
            camera_gain->textsize(10);
            camera_gain->align(FL_ALIGN_RIGHT);
          } // Fl_Value_Slider* camera_gain
          { camera_load_settings = new Fl_Button(609, 360, 120, 25, "Load Settings");
          } // Fl_Button* camera_load_settings
          { camera_save_settings = new Fl_Button(739, 360, 120, 25, "Save Settings");
          } // Fl_Button* camera_save_settings
          camera_settings->end();
        } // Fl_Group* camera_settings
          { image_display_b = new ImageDisplay(290, 80, 300, 360, "Display Box");
          image_display_b->box(FL_ENGRAVED_FRAME);
          image_display_b->color((Fl_Color)FL_BACKGROUND_COLOR);
          image_display_b->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
          image_display_b->labeltype(FL_NORMAL_LABEL);
          image_display_b->labelfont(0);
          image_display_b->labelsize(14);
          image_display_b->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
          image_display_b->align(FL_ALIGN_CENTER);
          image_display_b->when(FL_WHEN_RELEASE);
        } // ImageDisplay* image_display_b
        { button_start_camera_separate = new Fl_Button(300, 450, 120, 25, "Start Camera");
          button_start_camera_separate->type(1);
          button_start_camera_separate->callback((Fl_Callback*)cb_button_start_camera_separate);
        } // Fl_Button* button_start_camera_separate
        { Fl_Button* o = new Fl_Button(300, 500, 40, 30, "@>");
          o->box(FL_PLASTIC_UP_BOX);
          o->down_box(FL_PLASTIC_DOWN_BOX);
          o->callback((Fl_Callback*)cb_);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(350, 500, 40, 30, "@square");
          o->box(FL_PLASTIC_UP_BOX);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(400, 500, 40, 30, "@|>");
          o->box(FL_PLASTIC_UP_BOX);
        } // Fl_Button* o
        { Fl_Button* o = new Fl_Button(450, 500, 40, 30, "@<|");
          o->box(FL_PLASTIC_UP_BOX);
        } // Fl_Button* o
        { button_record = new Fl_Button(500, 500, 40, 30, "@circle");
          // button_record->type(1);
          button_record->box(FL_PLASTIC_UP_BOX);
          button_record->labelcolor((Fl_Color)FL_RED);
          button_record->callback((Fl_Callback*)cb_button_record);
        } // Fl_Button* button_record
        { Fl_Value_Slider* o = new Fl_Value_Slider(300, 550, 505, 15, "Frame");
          o->type(1);
          o->box(FL_PLASTIC_UP_BOX);
          o->maximum(200);
          o->step(1);
          o->textsize(14);
          o->align(FL_ALIGN_BOTTOM_LEFT);
        } // Fl_Value_Slider* o
        camera_control->end();
      } // Fl_Group* camera_control

      { training_trajectories = new Fl_Group(280, 55, 600, 590, "Training");
        training_trajectories->hide();
        { Fl_Button* o = new Fl_Button(280, 80, 160, 25, "Select file");
          o->callback((Fl_Callback*)cb_Select);
        } // Fl_Button* o
        { training_file_name_separate = new Fl_Input(460, 100, 320, 27, "Trajectory File:");
          training_file_name_separate->align(FL_ALIGN_TOP_LEFT);
        } // Fl_Input* training_file_name_separate
        { read_trajectory_file_separate = new Fl_Button(280, 105, 160, 25, "Read in Trajectory");
          read_trajectory_file_separate->callback((Fl_Callback*)cb_read_trajectory_file_separate);
        } // Fl_Button* read_trajectory_file_separate
        { Fl_Button* o = new Fl_Button(280, 130, 160, 25, "Start Training");
          o->callback((Fl_Callback*)cb_Start);
        } // Fl_Button* o
        { Fl_Input* o = new Fl_Input(460, 160, 320, 28, "Training Record:");
          o->align(FL_ALIGN_TOP_LEFT);
        } // Fl_Input* o
        { new Fl_Button(280, 155, 160, 25, "Pause");
        } // Fl_Button* o
        { new Fl_Button(280, 180, 160, 25, "Stop Training");
        } // Fl_Button* o
        training_trajectories->end();
      } // Fl_Group* training_trajectories
      { all_together = new Fl_Group(280, 55, 600, 590, "All Together");
        all_together->hide();
        { image_display_m = new ImageDisplay(375, 64, 512, 384, "Display Image");
          image_display_m->box(FL_ENGRAVED_FRAME);
          image_display_m->color((Fl_Color)FL_BACKGROUND_COLOR);
          image_display_m->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
          image_display_m->labeltype(FL_NORMAL_LABEL);
          image_display_m->labelfont(0);
          image_display_m->labelsize(14);
          image_display_m->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
          image_display_m->align(FL_ALIGN_CENTER);
          image_display_m->when(FL_WHEN_RELEASE);
        } // ImageDisplay* image_display_m
        { training_file_name = new Fl_Input(375, 473, 510, 27, "Trajectory File:");
          training_file_name->align(FL_ALIGN_TOP_LEFT);
        } // Fl_Input* training_file_name
        { training_progress = new Fl_Progress(375, 510, 510, 20, "Training Progress");
          training_progress->align(FL_ALIGN_BOTTOM);
        } // Fl_Progress* training_progress
        { check_calibrate_thumb = new Fl_Check_Button(280, 62, 125, 18, "Thumb");
          check_calibrate_thumb->down_box(FL_DOWN_BOX);
          check_calibrate_thumb->callback((Fl_Callback*)cb_check_calibrate_thumb);
        } // Fl_Check_Button* check_calibrate_thumb
        { button_maglev_connect = new Fl_Button(280, 90, 80, 25, "Connect");
          button_maglev_connect->type(1);
          button_maglev_connect->callback((Fl_Callback*)cb_button_maglev_connect);
        } // Fl_Button* button_maglev_connect
        { button_maglev_lift_land = new Fl_Button(280, 115, 80, 25, "Lift Off");
          button_maglev_lift_land->type(1);
          button_maglev_lift_land->callback((Fl_Callback*)cb_button_maglev_lift_land);
        } // Fl_Button* button_maglev_lift_land
        { button_start_camera = new Fl_Button(280, 140, 80, 25, "Camera");
          button_start_camera->type(1);
          button_start_camera->callback((Fl_Callback*)cb_button_start_camera);
        } // Fl_Button* button_start_camera
        { choose_trajectory_file = new Fl_Button(280, 165, 80, 25, "Traj File");
          choose_trajectory_file->callback((Fl_Callback*)cb_choose_trajectory_file);
        } // Fl_Button* choose_trajectory_file
        { read_trajectory_file = new Fl_Button(280, 190, 80, 25, "Read File");
          read_trajectory_file->callback((Fl_Callback*)cb_read_trajectory_file);
        } // Fl_Button* read_trajectory_file
        { start_force_controller = new Fl_Button(280, 215, 80, 25, "Controller");
          start_force_controller->type(1);
          start_force_controller->callback((Fl_Callback*)cb_start_force_controller);
        } // Fl_Button* start_force_controller
        { start_training = new Fl_Button(280, 240, 80, 25, "Start");
          start_training->callback((Fl_Callback*)cb_start_training);
        } // Fl_Button* start_training
        all_together->end();
      } // Fl_Group* all_together
      o->end();
    } // Fl_Tabs* o
    control_window->end();
  } // Fl_Double_Window* control_window
  control_window->show();
  // printf("End of the pop-up window \n");
  
  // { PopupCameraWindow = new Fl_Double_Window(550, 450, "Camera 1");
  //   PopupCameraWindow->end();
  // } // Fl_Double_Window* PopupCameraWindow
  // PopupCameraWindow->show();
  // printf("End of the second window \n");

  return Fl::run();
  // } 
}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%% End of Main Loop %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

